#define DEFINE_NAPI_Initialize(T) \
void T::NAPI_Initialize(napi_env env) { \
  std::vector<napi_property_descriptor> class_descriptors =  \
      T::__NAPI_GetClassPropertyDescriptors(); \
  std::vector<napi_property_descriptor> decorate_descriptors =  \
      T::__NAPI_GetDecoratePropertyDescriptors(); \
  napi_value constructor; \
 \
  NAPI_CALL(napi_define_class(env, T::__NAPI_GetClassName().c_str(), NAPI_AUTO_LENGTH, NAPI_Constructor, NULL, \
                class_descriptors.size(), class_descriptors.data(), &constructor)); \
  napi_value decorate = napi::create_empty_object(); \
  /* For some reason, this not work. instead, iterate over properties */ \
  /* NAPI_CALL(napi_define_properties(env, decorate, decorate_descriptors.size(), decorate_descriptors.data())) */ \
  for (auto& deco : decorate_descriptors) \
    NAPI_CALL(napi_set_named_property(env, decorate, deco.utf8name, deco.value)); \
  napi_value decorator[2]; \
  decorator[0] = constructor; \
  decorator[1] = decorate; \
  napi::log(decorator[0]); \
  napi::log(decorator[1]); \
  napi::log(napi::mobx_decorate()); \
  NAPI_CALL(napi_call_function(env, napi::mobx(), napi::mobx_decorate(), 2, decorator, &constructor)); \
 \
  napi_value parent_constructor = T::__NAPI_GetParentConstructor(); \
  if (parent_constructor) { \
    napi_value this_prototype = napi::GetNamedProperty(constructor, "prototype"); \
    napi_value parent_prototype = napi::GetNamedProperty(parent_constructor, "prototype"); \
    napi_value target_and_sources[2] = { this_prototype, parent_prototype }; \
    napi::ObjectAssign(2, target_and_sources); \
  } \
  napi::log(napi_encoder<const char*>::encode("TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT")); \
  napi::log(constructor); \
 \
  NAPI_CALL(napi_create_reference(env, constructor, 1, &__napi_constructor_reference_)); \
}